generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Tenant {
  id        String   @id @default(uuid())
  cnpj      String   @unique
  phone     String   @unique
  name      String
  site      String?
  email     String?
  description String?
  businessHours Json?
  aiTokenApi    String?
  metaTokenApi  String?
  agentInstruction String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FaqCategory {
  id       String     @id @default(uuid())
  tenantId String
  name     String @unique
  entries  FaqEntry[]

  @@unique([tenantId, name])
}

model FaqEntry {
  id         String      @id @default(uuid())
  question   String @unique
  answer     String
  categoryId String
  category   FaqCategory @relation(fields: [categoryId], references: [id])
}

model Department {
  id            String                 @id @default(uuid())
  tenantId      String
  name          String
  description   String?
  queues        DepartmentQueueEntry[]
  employees     Employee[]
  conversations Conversation[]

  @@unique([tenantId, name])
}

model DepartmentQueueEntry {
  id            String     @id @default(uuid())
  tenantId      String
  departmentId  String
  department    Department @relation(fields: [departmentId], references: [id])
  customerPhone String
  createdAt     DateTime   @default(now())

  @@unique([departmentId, customerPhone])
}

model Employee {
  id            String         @id @default(uuid())
  tenantId      String
  name          String
  phone         String
  departmentId  String?
  department    Department?    @relation(fields: [departmentId], references: [id])
  conversations Conversation[]

  @@unique([tenantId, phone])
}

model Conversation {
  id            String                  @id @default(uuid())
  tenantId      String
  employeeId    String
  employee      Employee                @relation(fields: [employeeId], references: [id])
  customerPhone String
  departmentId  String?
  department    Department?             @relation(fields: [departmentId], references: [id])
  active        Boolean                 @default(true)
  startedAt     DateTime                @default(now())
  endedAt       DateTime?
  // When the customer arrived in the queue that originated this conversation (if any)
  arrivedAt     DateTime?
  // Resolution classification to distinguish successful vs. unfinished endings
  resolution    ConversationResolution?
  messages      Message[]
  aiChatSession AIChatSession?
  finalSummary  String?

  @@index([tenantId, employeeId, active])
  @@index([tenantId, customerPhone, active])
}

enum ConversationResolution {
  RESOLVED
  UNRESOLVED
}

model SessionContext {
  id        String   @id @default(uuid())
  tenantId  String
  phone     String
  state     String
  data      String? // JSON-serialized snapshot data (if any)
  aiSessionId String?
  version   Int      @default(1)
  updatedAt DateTime @updatedAt

  @@unique([tenantId, phone])
}

// Tracks AI-only chat sessions for metrics (count per period) and analysis
model AIChatSession {
  id             String        @id @default(uuid())
  tenantId       String
  phone          String
  startedAt      DateTime      @default(now())
  endedAt        DateTime?
  endReason      String? // e.g. COMPLETED, ESCALATED, USER_EXITED, TIMEOUT
  conversationId String?       @unique
  conversation   Conversation? @relation(fields: [conversationId], references: [id])
  messages       AIMessage[]
  finalSummary   String?

  @@index([tenantId, phone, startedAt])
}

enum AIMessageSender {
  USER
  AI
}

model AIMessage {
  id               String           @id @default(uuid())
  aiChatSessionId  String
  aiChatSession    AIChatSession    @relation(fields: [aiChatSessionId], references: [id])
  sender           AIMessageSender
  text             String
  createdAt        DateTime         @default(now())

  @@index([aiChatSessionId, createdAt])
}

/// Known customers (by phone) per tenant
model Customer {
  id         String   @id @default(uuid())
  tenantId   String
  phone      String
  name       String
  email      String?
  profession String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([tenantId, phone])
}

enum MessageSender {
  EMPLOYEE
  CUSTOMER
}

model Message {
  id             String        @id @default(uuid())
  conversationId String
  conversation   Conversation  @relation(fields: [conversationId], references: [id])
  sender         MessageSender
  text           String
  createdAt      DateTime      @default(now())

  @@index([conversationId, createdAt])
}

enum UserRole {
  ADMIN
  EMPLOYEE
}

model User {
  id           String   @id @default(uuid())
  tenantId     String?
  email        String
  phone        String
  name         String
  passwordHash String
  role         UserRole @default(ADMIN)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([tenantId, email])
  @@unique([tenantId, phone])
  @@unique([tenantId, id])
}

/// Maps each tenant to its OpenAI Vector Store ID
model TenantVectorStore {
  id            String   @id @default(uuid())
  tenantId      String   @unique
  vectorStoreId String
  createdAt     DateTime @default(now())
}

/// Stored files metadata per tenant (for S3/R2 and OpenAI indexing)
model File {
  id             String   @id @default(uuid())
  tenantId       String
  key            String   @unique
  name           String
  contentType    String
  meta           Json?
  indexInStorage String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}
